encoding  utf-8

layout base-p

legend on
legend-columns 1
# legend-width 20 cm
# map-header x y position
# map-header-bg on
north true

# Scale
scale 1 200
scale-bar 20 m
# Scale of symbols
base-scale 1 200

# color map-bg [80 80 80]
# color map-fg [85 96 94] 

language sl

symbol-hide line survey
symbol-hide point station

# Scalebar
code metapost
  def s_scalebar (expr l, units, txt) =
  % l = value of scale-bar length
  % units = ??
  % txt = string representing units
    begingroup
      interim warningcheck:=0;
      tmpl:=l / Scale * cm * units / 2;
      % tmpl = half plotted length of scale bar from central top insertion point  
      tmpx:=l / Scale * cm * units / 5;
      tmph:=5bp; % bar height
    endgroup;
    pickup PenC;
    draw (-tmpl,0)--(tmpl,0)--(tmpl,-tmph)--(-tmpl,-tmph)--cycle;
    p:=(0,0)--(tmpx,0)--(tmpx,-tmph)--(0,-tmph)--cycle;
    for i:=-0.5 step 2 until 2:   % start drawing at the third block (leave space for smaller divisions)
      fill p shifted (i * tmpx,0);
    endfor;
    
    % Draw first part with subdivided blocks
    p:=(0,0)--(tmpx/5,0)--(tmpx/5,-tmph)--(0,-tmph)--cycle;  % define width of segment (tmpx is length of a normal bar segment)
    for i:=-2.5 step 2/5 until -0.75:                        % Startpos, segments, count-index
      fill p shifted (i * tmpx,0) withcolor black;
    endfor;
    
    % Label of scale: Scalebar top, values below
    begingroup
      interim labeloffset:=3.5bp;
      for i:=0 step (l/5) until (l-1):
        tmpx:=tmpl * (i * 2 / l - 1);
        label.bot(thTEX(decimal (i)),(tmpx,-tmph));
      endfor;
      label.bot(thTEX(decimal (l) & "\thinspace" & txt),(tmpl,-tmph));
      label.top(thTEX("Merilo/Scale 1 : " & decimal round(Scale*100)),(0,0));
    endgroup;
    
  enddef;
endcode

# Altitude enclircled
code metapost
  p_label_mode_altitude:=5;
endcode

# Frame
code metapost
code tex-map
   \framethickness=0.5mm
endcode

# POINT SYMBOLS

# Gradient symbol
code metapost
  def p_gradient_MY (expr pos,theta,sc,al) =
      U:=(.15u, .4u);
      T:=identity aligned al rotated theta scaled sc shifted pos;
      pickup PenC;

      #Left Hand side
      thdraw (-.2u, -.05u) -- (-.6u, .8u);

      #Centerline
      thdraw (0u, 0u) -- (0u, .9u);

      #Right side
      thdraw (.2u, -.05u) -- (.6u, .8u);
  enddef;
  
  initsymbol ("p_gradient_MY");
endcode
symbol-assign point gradient MY

# Restriction symbol, call with "point u:r"
code metapost
def p_u_r(expr P,R,S,A)=
  U := (.4u,.4u);
  T := identity aligned A rotated R scaled S shifted P;

  save txt; picture txt;
  txt := nullpicture;
  addto txt also ("r" infont defaultfont scaled defaultscale) withcolor (0,0.2,0.4);
  p_label.urt(txt, (0,0) transformed T, 0, 8);
enddef;
initsymbol("p_u_r");


# Sidemount restriction symbol, call with "point u:rsm"
code metapost
def p_u_rsm(expr P,R,S,A)=
  U := (.4u,.4u);
  T := identity aligned A rotated R scaled S shifted P;

  save txt; picture txt;
  txt := nullpicture;
  addto txt also ("r-sm" infont defaultfont scaled defaultscale) withcolor (0,0.2,0.4);
  p_label.urt(txt, (0,0) transformed T, 0, 8);
enddef;
initsymbol("p_u_rsm");

# LINE SYMBOLS

# Dive line
code metapost
  def l_u_diveline (expr P) =
  T:=identity;
  pickup PenB;
  thdraw P withcolor (1, 0.5, 0);
enddef;
initsymbol("l_u_diveline");
endcode

# Jump/Temporary line (dashed)
code metapost
  def l_u_jumpline (expr P) =
  T:=identity;
  pickup PenB;
  thdraw P withcolor (1, 0.5, 0) dashed evenly scaled 2;
enddef;
initsymbol("l_u_jumpline");
endcode

# AREA SYMBOLS

# Color water areas in light blue
code metapost
	def a_water (expr p) =
		T:=identity;
		thfill p withcolor (0.87, 0.92, 1);
	enddef;
endcode

# Sand - random dots, options for colored background
code metapost
    def a_sand_MY (expr p) =
        T:=identity;
        %thclean p;
        pickup PenB;
        %thfill p withcolor(0.85,0.8,0.5);
        path q; q = bbox p;
        picture tmp_pic, tmp_sand;
        pair z;
        tmp_sand := image (
        draw (-.005u,0)--(.007u,0);
        );
        tmp_pic := image(
        for i = xpart llcorner q step .7u until xpart urcorner q:
        for j = ypart llcorner q step .7u until ypart urcorner q:
        z := ((i,j) randomized 0.3u);
        if xpart (p intersectiontimes ((bbox tmp_sand) shifted z)) < 0:
        draw tmp_sand shifted z;
        fi;
        endfor;
        endfor;
        );
        clip tmp_pic to p;
        drawoptions();
        draw tmp_pic;
    enddef;
initsymbol("a_sand_MY");
symbol-assign area sand MY

# Blocks area symbols with adjustable density
code metapost
	def a_blocks_MY (expr p) =
	  T:=identity;
	  pickup PenD;
	  path q, qq; q = bbox p;
	  picture tmp_pic;
	  uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart llcorner q)/100);
	  tmp_pic := image(
	    for i = xpart llcorner q step 0.6uu until xpart urcorner q:
	      for j = ypart llcorner q step 0.6uu until ypart urcorner q:
	        k := (4+normaldeviate)/5;
	        qq := punked (((-.17uu,.07uu)--(-.17uu,-.07uu)--(0,-.12uu)--(.17uu,-.08uu)--(.15uu,.06uu)--(0,.13uu)--cycle)
	       randomized (uu/9))
	         rotated uniformdeviate(360)
	         scaled k
	         shifted ((i,j) randomized 0.3uu);

	  if xpart (p intersectiontimes qq) < 0:
	    thclean qq;
	    thdraw qq withcolor(0.3,0.3,0.3);
	  fi;
	      endfor;
	    endfor;
	  );
	  clip tmp_pic to p;
	  drawoptions();
	  draw tmp_pic;
	enddef;

	initsymbol("a_blocks_MY");
    symbol-assign area blocks MY

endlayout